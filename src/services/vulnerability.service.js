import mongoose from 'mongoose';
import Vulnerability from '../models/vulnerability.model.js';
import Scan from '../models/scan.model.js';
import { ApiError } from '../utils/ApiError.js';

export class VulnerabilityService {
    async createVulnerability(vulnerabilityData) {
        try {
            const vulnerability = await Vulnerability.create(vulnerabilityData);

            // Update scan statistics
            await this.updateScanStats(vulnerability.scanId);

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async createBulkVulnerabilities(vulnerabilities) {
        try {
            const created = await Vulnerability.insertMany(vulnerabilities, {
                ordered: false,
                rawResult: false
            });

            // Update scan statistics for affected scans
            const scanIds = [...new Set(vulnerabilities.map(v => v.scanId))];
            await Promise.all(scanIds.map(scanId => this.updateScanStats(scanId)));

            return created;
        } catch (error) {
            // Handle duplicate key errors gracefully
            if (error.code === 11000) {
                console.log('Some vulnerabilities already exist, continuing...');
                return [];
            }
            this.handleError(error);
        }
    }

    async getVulnerabilities(options) {
        try {
            const {
                // Search
                search,
                
                // Pagination
                page, limit,
                
                // Filters
                severity, status, type, scanId, ruleId, orgId,
                
                // Sorting
                sortBy, order,
                
                // Grouping
                // groupBy
            } = options;

            // Base query with organization filter
            const query = { orgId };

            // Apply filters
            if (severity) query.severity = severity;
            if (status) query.status = status;
            if (type) query.type = type;
            if (scanId) {
                query.scanId = scanId;
            }
            if (ruleId) query.ruleId = ruleId;

            // Add search functionality
            if (search && search.trim()) {
                query.$text = { $search: search.trim() };
            }

            // Handle groupBy for backward compatibility
            // if (groupBy === 'severity') {
            //     const grouped = await Vulnerability.aggregate([
            //         { $match: query },
            //         {
            //             $group: {
            //                 _id: '$severity',
            //                 count: { $sum: 1 },
            //                 vulnerabilities: { $push: '$$ROOT' }
            //             }
            //         },
            //         { $sort: { _id: 1 } }
            //     ]);

            //     return {
            //         data: grouped,
            //         page: 1,
            //         limit: grouped.length,
            //         total: grouped.length,
            //         pages: 1
            //     };
            // }

            // Build sort object
            const sort = {};
            sort[sortBy] = order === 'asc' ? 1 : -1;

            // Add text score sorting if searching
            if (search && search.trim()) {
                sort.score = { $meta: 'textScore' };
            }

            console.log("[+] FINAL QUERY: ", query);

            // Get total count
            const total = await Vulnerability.countDocuments(query);
            const pages = Math.ceil(total / limit);
            const skip = (page - 1) * limit;

            // Build query with population
            let vulnerabilityQuery = Vulnerability.find(query)
                .populate('ruleId', 'ruleName description')
                .populate('requestId', 'name method url')
                .populate('scanId', 'name status createdAt')
                .sort(sort)
                .skip(skip)
                .limit(limit)
                .lean();

            // Add text score projection if searching
            if (search && search.trim()) {
                vulnerabilityQuery = vulnerabilityQuery.select({
                    score: { $meta: 'textScore' }
                });
            }

            const vulnerabilities = await vulnerabilityQuery;

            const supported_filters = {};

            supported_filters.scans = await Scan.find({ orgId }, { name: 1, _id: 1 });
            supported_filters.severity = await Vulnerability.distinct("severity", { orgId });
            supported_filters.status = await Vulnerability.distinct("status", { orgId });

            return {
                data: vulnerabilities,
                filters: supported_filters,
                page,
                limit,
                total,
                pages
            };
        } catch (error) {
            this.handleError(error);
        }
    }

    async getVulnerability(id, orgId) {
        try {
            const vulnerability = await Vulnerability.findOne({
                _id: id,
                orgId
            })
                .populate('scanId', 'name status createdAt')
                .populate('ruleId', 'ruleName description report')
                .populate('requestId', 'name method url collectionName')
                .lean();

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async updateVulnerability(id, updateData, orgId) {
        try {
            // Remove fields that shouldn't be updated directly
            const {
                _id, scanId, ruleId, requestId, orgId: org,
                createdAt, updatedAt, ...safeUpdateData
            } = updateData;

            const vulnerability = await Vulnerability.findOneAndUpdate(
                { _id: id, orgId },
                { $set: safeUpdateData },
                { new: true, runValidators: true }
            );

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            // Update scan stats if status changed
            if (updateData.status) {
                await this.updateScanStats(vulnerability.scanId);
            }

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async addNote(id, text, orgId, userId) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            await vulnerability.addNote(text, userId);
            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async markAsFalsePositive(id, reason, orgId, userId) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            if (!reason) {
                throw ApiError.badRequest('Reason is required for marking as false positive');
            }

            await vulnerability.markAsFalsePositive(reason, userId);

            // Update scan stats
            await this.updateScanStats(vulnerability.scanId);

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async resolveVulnerability(id, notes, orgId, userId) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            await vulnerability.resolve(notes, userId);

            // Update scan stats
            await this.updateScanStats(vulnerability.scanId);

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async getVulnerabilityStats(orgId, timeRange) {
        try {
            // Parse time range
            const rangeValue = parseInt(timeRange);
            const rangeUnit = timeRange.slice(-1);
            let dateFilter = new Date();

            switch (rangeUnit) {
                case 'd':
                    dateFilter.setDate(dateFilter.getDate() - rangeValue);
                    break;
                case 'w':
                    dateFilter.setDate(dateFilter.getDate() - (rangeValue * 7));
                    break;
                case 'm':
                    dateFilter.setMonth(dateFilter.getMonth() - rangeValue);
                    break;
                default:
                    dateFilter.setDate(dateFilter.getDate() - 30);
            }

            const stats = await Vulnerability.aggregate([
                {
                    $match: {
                        orgId,
                        createdAt: { $gte: dateFilter }
                    }
                },
                {
                    $facet: {
                        bySeverity: [
                            {
                                $group: {
                                    _id: '$severity',
                                    count: { $sum: 1 }
                                }
                            }
                        ],
                        byStatus: [
                            {
                                $group: {
                                    _id: '$status',
                                    count: { $sum: 1 }
                                }
                            }
                        ],
                        byType: [
                            {
                                $group: {
                                    _id: '$type',
                                    count: { $sum: 1 }
                                }
                            },
                            { $sort: { count: -1 } },
                            { $limit: 10 }
                        ],
                        timeline: [
                            {
                                $group: {
                                    _id: {
                                        $dateToString: {
                                            format: '%Y-%m-%d',
                                            date: '$createdAt'
                                        }
                                    },
                                    count: { $sum: 1 }
                                }
                            },
                            { $sort: { _id: 1 } }
                        ],
                        recentVulnerabilities: [
                            { $sort: { createdAt: -1 } },
                            { $limit: 5 },
                            {
                                $project: {
                                    title: 1,
                                    severity: 1,
                                    type: 1,
                                    status: 1,
                                    createdAt: 1
                                }
                            }
                        ]
                    }
                },
                {
                    $project: {
                        bySeverity: {
                            $arrayToObject: {
                                $map: {
                                    input: '$bySeverity',
                                    as: 'item',
                                    in: { k: '$$item._id', v: '$$item.count' }
                                }
                            }
                        },
                        byStatus: {
                            $arrayToObject: {
                                $map: {
                                    input: '$byStatus',
                                    as: 'item',
                                    in: { k: '$$item._id', v: '$$item.count' }
                                }
                            }
                        },
                        topTypes: '$byType',
                        timeline: '$timeline',
                        recentVulnerabilities: '$recentVulnerabilities'
                    }
                }
            ]);

            // Get total counts
            const totalActive = await Vulnerability.countDocuments({
                orgId,
                status: 'active'
            });

            const totalResolved = await Vulnerability.countDocuments({
                orgId,
                status: 'resolved'
            });

            return {
                summary: {
                    totalActive,
                    totalResolved,
                    timeRange
                },
                ...stats[0]
            };
        } catch (error) {
            this.handleError(error);
        }
    }

    async exportVulnerabilities(options) {
        try {
            const { format, scanId, severity, status, orgId } = options;

            const query = { orgId };
            if (scanId) query.scanId = scanId;
            if (severity) query.severity = severity;
            if (status) query.status = status;

            const vulnerabilities = await Vulnerability.find(query)
                .populate('ruleId', 'ruleName description')
                .populate('requestId', 'name method url')
                .sort({ severity: 1, createdAt: -1 })
                .lean();

            if (format === 'csv') {
                return this.generateCSV(vulnerabilities);
            } else {
                return vulnerabilities;
            }
        } catch (error) {
            this.handleError(error);
        }
    }

    generateCSV(vulnerabilities) {
        const headers = [
            'Title',
            'Type',
            'Severity',
            'Status',
            'URL',
            'Method',
            'Description',
            'First Detected',
            'CWE',
            'OWASP'
        ].join(',');

        const rows = vulnerabilities.map(v => {
            return [
                `"${v.title}"`,
                v.type,
                v.severity,
                v.status,
                `"${v.requestDetails?.url || ''}"`,
                v.requestDetails?.method || '',
                `"${v.description.replace(/"/g, '""')}"`,
                new Date(v.firstDetectedAt).toISOString(),
                v.cwe || '',
                v.owasp || ''
            ].join(',');
        });

        return [headers, ...rows].join('\n');
    }

    async updateScanStats(scanId) {
        try {
            const stats = await Vulnerability.aggregate([
                { $match: { scanId: new mongoose.Types.ObjectId(scanId) } },
                {
                    $group: {
                        _id: null,
                        total: { $sum: 1 },
                        bySeverity: {
                            $push: '$severity'
                        }
                    }
                }
            ]);

            if (stats.length > 0) {
                const severityCounts = stats[0].bySeverity.reduce((acc, severity) => {
                    acc[severity] = (acc[severity] || 0) + 1;
                    return acc;
                }, {});

                await Scan.findByIdAndUpdate(scanId, {
                    'stats.vulnerabilitiesFound': stats[0].total,
                    'vulnerabilitySummary': {
                        critical: severityCounts.critical || 0,
                        high: severityCounts.high || 0,
                        medium: severityCounts.medium || 0,
                        low: severityCounts.low || 0,
                        informational: severityCounts.informational || 0
                    }
                });
            }
        } catch (error) {
            console.error('Error updating scan stats:', error);
        }
    }

    async checkDuplicateVulnerability(vulnerabilityData) {
        const { orgId, ruleId, requestId, evidence } = vulnerabilityData;

        const existing = await Vulnerability.findOne({
            orgId,
            ruleId,
            requestId,
            'evidence.request.url': evidence.request.url,
            status: 'active'
        });

        return existing;
    }

    handleError(error) {
        console.error('VulnerabilityService Error:', error);

        if (error.name === 'CastError') {
            throw ApiError.badRequest('Invalid ID format');
        }

        if (error.name === 'ValidationError') {
            const messages = Object.values(error.errors).map(e => e.message);
            throw ApiError.validationError('Validation failed', messages);
        }

        if (error instanceof ApiError) {
            throw error;
        }

        throw ApiError.internal('An error occurred while processing vulnerability operation');
    }
}