import mongoose from 'mongoose';
import Vulnerability from '../models/vulnerability.model.js';
import { Supression } from '../models/supression.model.js';
import Scan from '../models/scan.model.js';
import Rule from '../models/rule.model.js';
import { ApiError } from '../utils/ApiError.js';
import { supressFilter } from '../utils/supressFilter.js';
import { mqbroker } from './rabbitmq.service.js';
const { ObjectId } = mongoose.Types;

export class VulnerabilityService {
    async createVulnerability(vulnerabilityData) {
        try {
            const vulnerability = await Vulnerability.create(vulnerabilityData);

            // Update scan statistics
            await this.updateScanStats(vulnerability.scanId);

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async createBulkVulnerabilities(vulnerabilities) {
        try {
            const created = await Vulnerability.insertMany(vulnerabilities, {
                ordered: false,
                rawResult: false
            });

            // Update scan statistics for affected scans
            const scanIds = [...new Set(vulnerabilities.map(v => v.scanId))];
            await Promise.all(scanIds.map(scanId => this.updateScanStats(scanId)));

            return created;
        } catch (error) {
            // Handle duplicate key errors gracefully
            if (error.code === 11000) {
                console.log('Some vulnerabilities already exist, continuing...');
                return [];
            }
            this.handleError(error);
        }
    }

    async getVulnerabilities(options) {
        try {
            const {
                // Search
                search,

                // Pagination
                page, limit,

                // Filters
                severity, status, type, scanId, ruleId, orgId, supressed, projectId,

                // Sorting
                sortBy, order,

                // Include details
                includeDetails
            } = options;

            // Base query with organization filter
            let query = { orgId };

            // Apply filters
            if (severity) {
                query.severity = Array.isArray(severity) ? { $in: severity } : severity;
            }
            if (status) {
                query.status = Array.isArray(status) ? { $in: status } : status;
            }
            if (type) {
                query.type = Array.isArray(type) ? { $in: type } : type;
            }
            if (scanId) {
                if (Array.isArray(scanId)) {
                    query.scanId = { $in: scanId.map(id => mongoose.Types.ObjectId.createFromHexString(id)) };
                } else {
                    query.scanId = mongoose.Types.ObjectId.createFromHexString(scanId);
                }
            }
            if (ruleId) {
                const queryKey = 'ruleSnapshot._id';
                if (Array.isArray(ruleId)) {
                    query[queryKey] = { $in: ruleId.map(id => mongoose.Types.ObjectId.createFromHexString(id)) };
                } else {
                    query[queryKey] = mongoose.Types.ObjectId.createFromHexString(ruleId);
                }
            } else {
                const inactiveRules = await Rule.find({ isActive: false, orgId: orgId }, '_id').lean();
                const inactiveRuleIds = inactiveRules.map(rule => rule._id);
                if (inactiveRuleIds.length > 0) {
                    query['ruleSnapshot._id'] = { $nin: inactiveRuleIds };
                }
            }

            // Add search functionality
            if (search && search.trim()) {
                query.$text = { $search: search.trim() };
            }

            // Build sort object
            const sort = {};
            sort[sortBy] = order === 'asc' ? 1 : -1;

            // Add text score sorting if searching
            if (search && search.trim()) {
                sort.score = { $meta: 'textScore' };
            }

            if (projectId) {
                if (Array.isArray(projectId)) {
                    query.projectId = { $in: projectId.map(id => mongoose.Types.ObjectId.createFromHexString(id)) };
                } else {
                    query.projectId = mongoose.Types.ObjectId.createFromHexString(projectId);
                }
            }

            const suppressionRules = await Supression.find({ orgId }).lean();

            // Apply suppression filter to the main query based on the 'supressed' parameter
            const suppress_filters = supressFilter(suppressionRules, supressed);

            query = { ...query, ...suppress_filters };

            // Get total count for pagination using the final query
            const total = await Vulnerability.countDocuments(query);
            const pages = Math.ceil(total / limit);
            const skip = (page - 1) * limit;

            // Get total summary counts (independent of filters, except for orgId)
            const suppressedFilter = supressFilter(suppressionRules, true);

            const [totalActive, totalResolved, totalSuppressed] = await Promise.all([
                Vulnerability.countDocuments({ orgId, status: 'active' }),
                Vulnerability.countDocuments({ orgId, status: 'resolved' }),
                Vulnerability.countDocuments({ orgId, ...suppressedFilter })
            ]);

            const pipeline = [];

            // 1️⃣ Apply main query filters
            if (Object.keys(query).length) {
                pipeline.push({ $match: query });
            }


            // add the attribute isSuppressed
            pipeline.push({
                $addFields: {
                    isSuppressed: {
                        $cond: [
                            { $and: [{ $in: ["$requestSnapshot._id", suppressionRules.map(r => ObjectId.createFromHexString(r.requestId))] }, { $in: ["$ruleSnapshot._id", suppressionRules.map(r => ObjectId.createFromHexString(r.ruleId))] } ] },
                            true,
                            false
                        ]
                    }
                }
            });

            // Deprecated: Lookups for ruleId and requestId are no longer needed.
            // 2️⃣ Populate ruleId
            // pipeline.push({
            // $lookup: {
            //     from: "rules",
            //     localField: "ruleId",
            //     foreignField: "_id",
            //     as: "ruleId",
            //     pipeline: [
            //     { $project: includeDetails ? { __v: 0 } : { ruleName: 1, description: 1, _id: 1 } }
            //     ]
            // }
            // });
            // pipeline.push({ $unwind: { path: "$ruleId", preserveNullAndEmptyArrays: true } });

            // 3️⃣ Populate requestId
            // pipeline.push({
            // $lookup: {
            //     from: "requests",
            //     localField: "requestId",
            //     foreignField: "_id",
            //     as: "requestId",
            //     pipeline: [
            //     { $project: includeDetails ? { __v: 0 } : { name: 1, method: 1, url: 1, _id: 1 } }
            //     ]
            // }
            // });
            // pipeline.push({ $unwind: { path: "$requestId", preserveNullAndEmptyArrays: true } });

            // 4️⃣ Populate scanId
            pipeline.push({
                $lookup: {
                    from: "scans",
                    localField: "scanId",
                    foreignField: "_id",
                    as: "scanId",
                    pipeline: [
                        {
                            $project: includeDetails
                                ? { name: 1, status: 1, createdAt: 1, completedAt: 1, _id: 1 }
                                : { name: 1, status: 1, createdAt: 1, _id: 1 }
                        }
                    ]
                }
            });
            pipeline.push({ $unwind: { path: "$scanId", preserveNullAndEmptyArrays: true } });

            // Deprecated - was buggy
            // // 5️⃣ Add isSuppressed per document if it matches suppress_filters
            // pipeline.push({
            //     $addFields: {
            //         isSuppressed: {
            //             $cond: [
            //                 {
            //                     $and: [
            //                         { $in: ["$requestSnapshot._id", rules.map(rule => rule.requestId)] },
            //                         { $in: ["$ruleSnapshot._id", rules.map(rule => rule.ruleId)] }
            //                     ]
            //                 },
            //                 true,
            //                 false
            //             ]
            //         }
            //     }
            // });

            // 6️⃣ Sort
            if (sort && Object.keys(sort).length) {
                pipeline.push({ $sort: sort });
            }

            // Add text score projection if searching
            if (search && search.trim()) {
                pipeline.push({ $addFields: { score: { $meta: 'textScore' } } });
            }

            // 7️⃣ Pagination
            if (skip) pipeline.push({ $skip: skip });
            if (limit) pipeline.push({ $limit: limit });

            // ✅ Execute
            const vulnerabilityQuery = Vulnerability.aggregate(pipeline);

            // Build query with population
            // let vulnerabilityQuery = Vulnerability.find(query)
            //     .populate('ruleId', includeDetails ? '-__v' : 'ruleName description')
            //     .populate('requestId', includeDetails ? '-__v' : 'name method url')
            //     // .populate('transformedRequestId', includeDetails ? '-__v' : 'name method url')
            //     .populate('scanId', 'name status createdAt' + (includeDetails ? ' completedAt' : ''))
            //     .sort(sort)
            //     .skip(skip)
            //     .limit(limit)
            //     .lean();

            let vulnerabilities = await vulnerabilityQuery;

            // If includeDetails is true, merge additional data into each vulnerability
            if (includeDetails) {
                vulnerabilities = await Promise.all(
                    vulnerabilities.map(async (vulnerability) => {
                        // Deprecated: transformedRequest is no longer fetched manually
                        // const transformedRequest = vulnerability.transformedRequestId ?
                        //     await mongoose.model('TransformedRequest')
                        //         .findById(vulnerability.transformedRequestId)
                        //         .select('-__v')
                        //         .lean() :
                        //     null;

                        // Merge everything directly into the vulnerability object
                        return {
                            ...vulnerability,

                            // Add computed fields
                            ageInDays: Math.floor((Date.now() - new Date(vulnerability.firstDetectedAt)) / (1000 * 60 * 60 * 24)),
                            isActive: vulnerability.status === 'active',
                            isResolved: ['resolved', 'false_positive'].includes(vulnerability.status),

                            // Add related data from snapshots
                            rawRequest: vulnerability.requestSnapshot || null,
                            transformedRequest: vulnerability.transformedRequestSnapshot || null,
                            rule: vulnerability.ruleSnapshot || null,

                            // Add details summary from snapshots
                            detailsSummary: {
                                originalEndpoint: vulnerability.requestSnapshot ?
                                    `${vulnerability.requestSnapshot.method} ${vulnerability.requestSnapshot.url}` : null,
                                appliedTransformations: vulnerability.transformedRequestSnapshot?.transformations?.length || 0,
                                ruleCategory: vulnerability.ruleSnapshot?.category || null,
                                detectionMethod: vulnerability.evidence?.matchedCriteria?.type || null
                            }
                        };
                    })
                );
            }

            const supported_filters = {};
            supported_filters.scans = await Scan.find({ orgId }, { name: 1, _id: 1 });
            supported_filters.rules = await Rule.find({ orgId, isActive: true }, { ruleName: 1, _id: 1 });
            supported_filters.severity = ["critical", "high", "medium", "low"];
            supported_filters.status = ["active", "inactive"];
            supported_filters.suppressed = [true, false];

            return {
                data: vulnerabilities,
                filters: supported_filters,
                page,
                limit,
                total,
                pages,
                // Add summary counts
                summary: {
                    totalActive,
                    totalResolved,
                    totalSuppressed
                }
            };
        } catch (error) {
            this.handleError(error);
        }
    }

    async getVulnerability(id, orgId) {
        try {
            const vulnerability = await Vulnerability.findOne({
                _id: id,
                orgId
            })
                .populate('scanId', 'name status createdAt')
            // Deprecated
            // .populate('ruleId', 'ruleName description report')
            // .populate('requestId', 'name method url collectionName')
                .lean();

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async updateVulnerability(id, updateData, orgId) {
        try {
            // Remove fields that shouldn't be updated directly
            const {
                _id, scanId, ruleId, requestId, orgId: org,
                createdAt, updatedAt, ...safeUpdateData
            } = updateData;

            const vulnerability = await Vulnerability.findOneAndUpdate(
                { _id: id, orgId },
                { $set: safeUpdateData },
                { new: true, runValidators: true }
            );

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            // Update scan stats if status changed
            if (updateData.status) {
                await this.updateScanStats(vulnerability.scanId);
            }

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async addNote(id, text, orgId, userId) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            await vulnerability.addNote(text, userId);
            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async markAsFalsePositive(id, reason, orgId, userId) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            if (!reason) {
                throw ApiError.badRequest('Reason is required for marking as false positive');
            }

            await vulnerability.markAsFalsePositive(reason, userId);

            // Update scan stats
            await this.updateScanStats(vulnerability.scanId);

            // Send notification for vulnerability suppression
            try {
                const notification = {
                    store: true,
                    orgId: orgId,
                    channels: ["email"],
                    notification: {
                        title: "Vulnerability Marked as False Positive",
                        description: `"${vulnerability.title}" (${vulnerability.severity}) has been marked as false positive.`,
                        resourceUrl: `/vulnerabilities/${vulnerability._id}`,
                        origin: "aim",
                        resourceMeta: {
                            product: "aim",
                            action: "vulnerability_suppression",
                            resource: "vulnerability"
                        }
                    },
                    context: {
                        name: userId || "User",
                        title: "Vulnerability Suppressed",
                        description: `The vulnerability "${vulnerability.title}" has been marked as a false positive and will be suppressed from active findings.

Details:
• Vulnerability Type: ${vulnerability.type}
• Severity: ${vulnerability.severity}
• Endpoint: ${vulnerability.requestDetails?.method || ''} ${vulnerability.requestDetails?.url || ''}
• Reason: ${reason}

This vulnerability will no longer appear in active vulnerability lists and won't affect your security posture metrics.`,
                        status: "success",
                        timestamp: Intl.DateTimeFormat('en-US', { dateStyle: 'medium', timeStyle: 'short' }).format(new Date()),
                        action_text: "View Details",
                        action_url: `https://suite.snapsec.co/vulnerabilities/${vulnerability._id}`,
                        base_url: "https://suite.snapsec.co",
                        subject: "Vulnerability Marked as False Positive - Snapsec"
                    },
                    orgCoverage: { roles: ["Member"] },
                    authContext: userId || 'system'
                };

                await mqbroker.publish("notification", "notification", notification);
            } catch (notificationError) {
                console.error('Failed to send false positive notification:', notificationError);
                // Don't throw - continue with the response
            }

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async resolveVulnerability(orgId, id) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            // notes and user Id
            // await vulnerability.resolve(notes, userId);

            // Update scan stats
            await this.updateScanStats(vulnerability.scanId);

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async updateVulnerabilityFromVM(vmVuln) {
        try {
            const { universalVulnId, state } = vmVuln;

            if (state !== 'Resolved') {
                console.log(`[+] Skipping vulnerability update for ${universalVulnId} as state is not 'Resolved'.`);
                return;
            }

            const vulnerability = await Vulnerability.findOne({ universalVulnId });

            if (!vulnerability) {
                console.log(`[+] Vulnerability with universalVulnId ${universalVulnId} not found.`);
                return;
            }

            if (vulnerability.status === 'resolved') {
                console.log(`[+] Vulnerability ${vulnerability._id} is already resolved.`);
                return;
            }

            // const notes = revalidation?.reason || 'Resolved via VM';
            // const user = revalidation?.revalidatedBy?.name || 'system';

            await this.resolveVulnerability(vulnerability._id, notes, vulnerability.orgId, user);
            console.log(`[+] Resolved vulnerability ${vulnerability._id} from VM event.`);

        } catch (error) {
            this.handleError(error);
        }
    }

    async getVulnerabilityStats(orgId, timeRange) {
        try {
            // Parse time range
            const rangeValue = parseInt(timeRange);
            const rangeUnit = timeRange.slice(-1);
            let dateFilter = new Date();

            switch (rangeUnit) {
                case 'd':
                    dateFilter.setDate(dateFilter.getDate() - rangeValue);
                    break;
                case 'w':
                    dateFilter.setDate(dateFilter.getDate() - (rangeValue * 7));
                    break;
                case 'm':
                    dateFilter.setMonth(dateFilter.getMonth() - rangeValue);
                    break;
                default:
                    dateFilter.setDate(dateFilter.getDate() - 30);
            }

            const stats = await Vulnerability.aggregate([
                {
                    $match: {
                        orgId,
                        createdAt: { $gte: dateFilter }
                    }
                },
                {
                    $facet: {
                        bySeverity: [
                            {
                                $group: {
                                    _id: '$severity',
                                    count: { $sum: 1 }
                                }
                            }
                        ],
                        byStatus: [
                            {
                                $group: {
                                    _id: '$status',
                                    count: { $sum: 1 }
                                }
                            }
                        ],
                        byType: [
                            {
                                $group: {
                                    _id: '$type',
                                    count: { $sum: 1 }
                                }
                            },
                            { $sort: { count: -1 } },
                            { $limit: 10 }
                        ],
                        timeline: [
                            {
                                $group: {
                                    _id: {
                                        $dateToString: {
                                            format: '%Y-%m-%d',
                                            date: '$createdAt'
                                        }
                                    },
                                    count: { $sum: 1 }
                                }
                            },
                            { $sort: { _id: 1 } }
                        ],
                        recentVulnerabilities: [
                            { $sort: { createdAt: -1 } },
                            { $limit: 5 },
                            {
                                $project: {
                                    title: 1,
                                    severity: 1,
                                    type: 1,
                                    status: 1,
                                    createdAt: 1
                                }
                            }
                        ]
                    }
                },
                {
                    $project: {
                        bySeverity: {
                            $arrayToObject: {
                                $map: {
                                    input: '$bySeverity',
                                    as: 'item',
                                    in: { k: '$$item._id', v: '$$item.count' }
                                }
                            }
                        },
                        byStatus: {
                            $arrayToObject: {
                                $map: {
                                    input: '$byStatus',
                                    as: 'item',
                                    in: { k: '$$item._id', v: '$$item.count' }
                                }
                            }
                        },
                        topTypes: '$byType',
                        timeline: '$timeline',
                        recentVulnerabilities: '$recentVulnerabilities'
                    }
                }
            ]);

            // Get total counts
            const totalActive = await Vulnerability.countDocuments({
                orgId,
                status: 'active'
            });

            const totalResolved = await Vulnerability.countDocuments({
                orgId,
                status: 'resolved'
            });

            return {
                summary: {
                    totalActive,
                    totalResolved,
                    timeRange
                },
                ...stats[0]
            };
        } catch (error) {
            this.handleError(error);
        }
    }

    async exportVulnerabilities(options) {
        try {
            const { format, scanId, severity, status, orgId } = options;

            const query = { orgId };
            if (scanId) query.scanId = scanId;
            if (severity) query.severity = severity;
            if (status) query.status = status;

            const vulnerabilities = await Vulnerability.find(query)
                // Deprecated
                // .populate('ruleId', 'ruleName description')
                // .populate('requestId', 'name method url')
                .sort({ severity: 1, createdAt: -1 })
                .lean();

            if (format === 'csv') {
                return this.generateCSV(vulnerabilities);
            } else {
                return vulnerabilities;
            }
        } catch (error) {
            this.handleError(error);
        }
    }

    generateCSV(vulnerabilities) {
        const headers = [
            'Title',
            'Type',
            'Severity',
            'Status',
            'URL',
            'Method',
            'Description',
            'First Detected',
            'CWE',
            'OWASP'
        ].join(',');

        const rows = vulnerabilities.map(v => {
            return [
                `"${v.title}"`,
                v.type,
                v.severity,
                v.status,
                `"${v.requestDetails?.url || ''}"`,
                v.requestDetails?.method || '',
                `"${v.description.replace(/"/g, '""')}"`,
                new Date(v.firstDetectedAt).toISOString(),
                v.cwe || '',
                v.owasp || ''
            ].join(',');
        });

        return [headers, ...rows].join('\n');
    }

    async updateScanStats(scanId) {
        try {
            const stats = await Vulnerability.aggregate([
                { $match: { scanId: new mongoose.Types.ObjectId(scanId) } },
                {
                    $group: {
                        _id: null,
                        total: { $sum: 1 },
                        bySeverity: {
                            $push: '$severity'
                        }
                    }
                }
            ]);

            if (stats.length > 0) {
                const severityCounts = stats[0].bySeverity.reduce((acc, severity) => {
                    acc[severity] = (acc[severity] || 0) + 1;
                    return acc;
                }, {});

                await Scan.findByIdAndUpdate(scanId, {
                    'stats.vulnerabilitiesFound': stats[0].total,
                    'vulnerabilitySummary': {
                        critical: severityCounts.critical || 0,
                        high: severityCounts.high || 0,
                        medium: severityCounts.medium || 0,
                        low: severityCounts.low || 0,
                        informational: severityCounts.informational || 0
                    }
                });
            }
        } catch (error) {
            console.error('Error updating scan stats:', error);
        }
    }

    async checkDuplicateVulnerability(vulnerabilityData) {
        const { orgId, ruleId, requestId, evidence } = vulnerabilityData;

        const existing = await Vulnerability.findOne({
            orgId,
            'ruleSnapshot._id': ruleId,
            'requestSnapshot._id': requestId,
            'evidence.request.url': evidence.request.url,
            status: 'active'
        });

        return existing;
    }

    async getVulnerabilityDetails(id, orgId) {
        try {
            // First get the vulnerability with basic populations
            const vulnerability = await Vulnerability.findOne({
                _id: id,
                orgId
            })
                .populate('scanId', 'name status createdAt completedAt')
                .lean();

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            // Deprecated: Manual fetching of related documents is no longer needed.
            // const [rawRequest, transformedRequest, rule] = await Promise.all([
            //     // Get raw request with full details
            //     mongoose.model('RawRequest').findById(vulnerability.requestId)
            //         .select('-__v')
            //         .lean(),

            //     // Get transformed request if it exists
            //     vulnerability.transformedRequestId ?
            //         mongoose.model('TransformedRequest').findById(vulnerability.transformedRequestId)
            //             .select('-__v')
            //             .lean() :
            //         null,

            //     // Get rule with full details
            //     mongoose.model('Rule').findById(vulnerability.ruleId)
            //         .select('-__v')
            //         .lean()
            // ]);

            // // Ensure all related data belongs to the same organization
            // if (rawRequest && rawRequest.orgId !== orgId) {
            //     throw ApiError.forbidden('Access denied to related data');
            // }

            // Build the comprehensive response
            const details = {
                vulnerability: {
                    ...vulnerability,
                    // Include computed fields
                    ageInDays: Math.floor((Date.now() - new Date(vulnerability.firstDetectedAt)) / (1000 * 60 * 60 * 24)),
                    isActive: vulnerability.status === 'active',
                    isResolved: ['resolved', 'false_positive'].includes(vulnerability.status)
                },
                rawRequest: vulnerability.requestSnapshot || null,
                transformedRequest: vulnerability.transformedRequestSnapshot || null,
                rule: vulnerability.ruleSnapshot || null,

                // Add summary information
                summary: {
                    originalEndpoint: vulnerability.requestSnapshot ? `${vulnerability.requestSnapshot.method} ${vulnerability.requestSnapshot.url}` : null,
                    appliedTransformations: vulnerability.evidence?.request?.transformations?.length || 0,
                    ruleCategory: vulnerability.ruleSnapshot?.category || null,
                    detectionMethod: vulnerability.evidence?.matchedCriteria?.type || null
                }
            };

            return details;
        } catch (error) {
            this.handleError(error);
        }
    }

    handleError(error) {
        console.error('VulnerabilityService Error:', error);

        if (error.name === 'CastError') {
            throw ApiError.badRequest('Invalid ID format');
        }

        if (error.name === 'ValidationError') {
            const messages = Object.values(error.errors).map(e => e.message);
            throw ApiError.validationError('Validation failed', messages);
        }

        if (error instanceof ApiError) {
            throw error;
        }

        throw ApiError.internal('An error occurred while processing vulnerability operation');
    }
}