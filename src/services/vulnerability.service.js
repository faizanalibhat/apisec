import mongoose from 'mongoose';
import Vulnerability from '../models/vulnerability.model.js';
import { Supression } from '../models/supression.model.js';
import Scan from '../models/scan.model.js';
import { ApiError } from '../utils/ApiError.js';
import { supressFilter } from '../utils/supressFilter.js';

export class VulnerabilityService {
    async createVulnerability(vulnerabilityData) {
        try {
            const vulnerability = await Vulnerability.create(vulnerabilityData);

            // Update scan statistics
            await this.updateScanStats(vulnerability.scanId);

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async createBulkVulnerabilities(vulnerabilities) {
        try {
            const created = await Vulnerability.insertMany(vulnerabilities, {
                ordered: false,
                rawResult: false
            });

            // Update scan statistics for affected scans
            const scanIds = [...new Set(vulnerabilities.map(v => v.scanId))];
            await Promise.all(scanIds.map(scanId => this.updateScanStats(scanId)));

            return created;
        } catch (error) {
            // Handle duplicate key errors gracefully
            if (error.code === 11000) {
                console.log('Some vulnerabilities already exist, continuing...');
                return [];
            }
            this.handleError(error);
        }
    }

    async getVulnerabilities(options) {
        try {
            const {
                // Search
                search,

                // Pagination
                page, limit,

                // Filters
                severity, status, type, scanId, ruleId, orgId, supressed,

                // Sorting
                sortBy, order,

                // Include details
                includeDetails
            } = options;

            // Base query with organization filter
            const query = { orgId };

            // Apply filters
            if (severity) query.severity = severity;
            if (status) query.status = status;
            if (type) query.type = type;
            if (scanId) {
                query.scanId = scanId;
            }
            if (ruleId) query.ruleId = ruleId;

            // Add search functionality
            if (search && search.trim()) {
                query.$text = { $search: search.trim() };
            }

            // Build sort object
            const sort = {};
            sort[sortBy] = order === 'asc' ? 1 : -1;

            // Add text score sorting if searching
            if (search && search.trim()) {
                sort.score = { $meta: 'textScore' };
            }

            const rules = await Supression.find({ orgId });

            let suppress_filters = supressFilter(rules, supressed);

            query.$and = [suppress_filters];

            console.log("[+] FINAL QUERY: ", query);

            // Get total count for pagination
            const total = await Vulnerability.countDocuments(query);
            const pages = Math.ceil(total / limit);
            const skip = (page - 1) * limit;

            // Get total active and resolved counts (without filters except orgId)
            const [totalActive, totalResolved] = await Promise.all([
                Vulnerability.countDocuments({ orgId, status: 'active' }),
                Vulnerability.countDocuments({ orgId, status: 'resolved' })
            ]);

            // Build query with population
            let vulnerabilityQuery = Vulnerability.find(query)
                .populate('ruleId', includeDetails ? '-__v' : 'ruleName description')
                .populate('requestId', includeDetails ? '-__v' : 'name method url')
                // .populate('transformedRequestId', includeDetails ? '-__v' : 'name method url')
                .populate('scanId', 'name status createdAt' + (includeDetails ? ' completedAt' : ''))
                .sort(sort)
                .skip(skip)
                .limit(limit)
                .lean();

            // Add text score projection if searching
            if (search && search.trim()) {
                vulnerabilityQuery = vulnerabilityQuery.select({
                    score: { $meta: 'textScore' }
                });
            }

            let vulnerabilities = await vulnerabilityQuery;

            // If includeDetails is true, merge additional data into each vulnerability
            if (includeDetails) {
                vulnerabilities = await Promise.all(
                    vulnerabilities.map(async (vulnerability) => {
                        // Fetch transformed request if it exists
                        const transformedRequest = vulnerability.transformedRequestId ?
                            await mongoose.model('TransformedRequest')
                                .findById(vulnerability.transformedRequestId)
                                .select('-__v')
                                .lean() :
                            null;

                        // Merge everything directly into the vulnerability object
                        return {
                            ...vulnerability,

                            // Add computed fields
                            ageInDays: Math.floor((Date.now() - new Date(vulnerability.firstDetectedAt)) / (1000 * 60 * 60 * 24)),
                            isActive: vulnerability.status === 'active',
                            isResolved: ['resolved', 'false_positive'].includes(vulnerability.status),

                            // Add related data
                            rawRequest: vulnerability.requestId || null,
                            transformedRequest: transformedRequest,
                            rule: vulnerability.ruleId || null,

                            // Add details summary
                            detailsSummary: {
                                originalEndpoint: vulnerability.requestId ?
                                    `${vulnerability.requestId.method} ${vulnerability.requestId.url}` : null,
                                appliedTransformations: transformedRequest?.transformations?.length || 0,
                                ruleCategory: vulnerability.ruleId?.category || null,
                                detectionMethod: vulnerability.evidence?.matchedCriteria?.type || null
                            }
                        };
                    })
                );
            }

            const supported_filters = {};
            supported_filters.scans = await Scan.find({ orgId }, { name: 1, _id: 1 });
            supported_filters.severity = ["critical", "high", "medium", "low"];
            supported_filters.status = ["active", "inactive"];

            return {
                data: vulnerabilities,
                filters: supported_filters,
                page,
                limit,
                total,
                pages,
                // Add summary counts
                summary: {
                    totalActive,
                    totalResolved
                }
            };
        } catch (error) {
            this.handleError(error);
        }
    }

    async getVulnerability(id, orgId) {
        try {
            const vulnerability = await Vulnerability.findOne({
                _id: id,
                orgId
            })
                .populate('scanId', 'name status createdAt')
                .populate('ruleId', 'ruleName description report')
                .populate('requestId', 'name method url collectionName')
                .lean();

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async updateVulnerability(id, updateData, orgId) {
        try {
            // Remove fields that shouldn't be updated directly
            const {
                _id, scanId, ruleId, requestId, orgId: org,
                createdAt, updatedAt, ...safeUpdateData
            } = updateData;

            const vulnerability = await Vulnerability.findOneAndUpdate(
                { _id: id, orgId },
                { $set: safeUpdateData },
                { new: true, runValidators: true }
            );

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            // Update scan stats if status changed
            if (updateData.status) {
                await this.updateScanStats(vulnerability.scanId);
            }

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async addNote(id, text, orgId, userId) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            await vulnerability.addNote(text, userId);
            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async markAsFalsePositive(id, reason, orgId, userId) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            if (!reason) {
                throw ApiError.badRequest('Reason is required for marking as false positive');
            }

            await vulnerability.markAsFalsePositive(reason, userId);

            // Update scan stats
            await this.updateScanStats(vulnerability.scanId);

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async resolveVulnerability(id, notes, orgId, userId) {
        try {
            const vulnerability = await Vulnerability.findOne({ _id: id, orgId });

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            await vulnerability.resolve(notes, userId);

            // Update scan stats
            await this.updateScanStats(vulnerability.scanId);

            return vulnerability;
        } catch (error) {
            this.handleError(error);
        }
    }

    async getVulnerabilityStats(orgId, timeRange) {
        try {
            // Parse time range
            const rangeValue = parseInt(timeRange);
            const rangeUnit = timeRange.slice(-1);
            let dateFilter = new Date();

            switch (rangeUnit) {
                case 'd':
                    dateFilter.setDate(dateFilter.getDate() - rangeValue);
                    break;
                case 'w':
                    dateFilter.setDate(dateFilter.getDate() - (rangeValue * 7));
                    break;
                case 'm':
                    dateFilter.setMonth(dateFilter.getMonth() - rangeValue);
                    break;
                default:
                    dateFilter.setDate(dateFilter.getDate() - 30);
            }

            const stats = await Vulnerability.aggregate([
                {
                    $match: {
                        orgId,
                        createdAt: { $gte: dateFilter }
                    }
                },
                {
                    $facet: {
                        bySeverity: [
                            {
                                $group: {
                                    _id: '$severity',
                                    count: { $sum: 1 }
                                }
                            }
                        ],
                        byStatus: [
                            {
                                $group: {
                                    _id: '$status',
                                    count: { $sum: 1 }
                                }
                            }
                        ],
                        byType: [
                            {
                                $group: {
                                    _id: '$type',
                                    count: { $sum: 1 }
                                }
                            },
                            { $sort: { count: -1 } },
                            { $limit: 10 }
                        ],
                        timeline: [
                            {
                                $group: {
                                    _id: {
                                        $dateToString: {
                                            format: '%Y-%m-%d',
                                            date: '$createdAt'
                                        }
                                    },
                                    count: { $sum: 1 }
                                }
                            },
                            { $sort: { _id: 1 } }
                        ],
                        recentVulnerabilities: [
                            { $sort: { createdAt: -1 } },
                            { $limit: 5 },
                            {
                                $project: {
                                    title: 1,
                                    severity: 1,
                                    type: 1,
                                    status: 1,
                                    createdAt: 1
                                }
                            }
                        ]
                    }
                },
                {
                    $project: {
                        bySeverity: {
                            $arrayToObject: {
                                $map: {
                                    input: '$bySeverity',
                                    as: 'item',
                                    in: { k: '$$item._id', v: '$$item.count' }
                                }
                            }
                        },
                        byStatus: {
                            $arrayToObject: {
                                $map: {
                                    input: '$byStatus',
                                    as: 'item',
                                    in: { k: '$$item._id', v: '$$item.count' }
                                }
                            }
                        },
                        topTypes: '$byType',
                        timeline: '$timeline',
                        recentVulnerabilities: '$recentVulnerabilities'
                    }
                }
            ]);

            // Get total counts
            const totalActive = await Vulnerability.countDocuments({
                orgId,
                status: 'active'
            });

            const totalResolved = await Vulnerability.countDocuments({
                orgId,
                status: 'resolved'
            });

            return {
                summary: {
                    totalActive,
                    totalResolved,
                    timeRange
                },
                ...stats[0]
            };
        } catch (error) {
            this.handleError(error);
        }
    }

    async exportVulnerabilities(options) {
        try {
            const { format, scanId, severity, status, orgId } = options;

            const query = { orgId };
            if (scanId) query.scanId = scanId;
            if (severity) query.severity = severity;
            if (status) query.status = status;

            const vulnerabilities = await Vulnerability.find(query)
                .populate('ruleId', 'ruleName description')
                .populate('requestId', 'name method url')
                .sort({ severity: 1, createdAt: -1 })
                .lean();

            if (format === 'csv') {
                return this.generateCSV(vulnerabilities);
            } else {
                return vulnerabilities;
            }
        } catch (error) {
            this.handleError(error);
        }
    }

    generateCSV(vulnerabilities) {
        const headers = [
            'Title',
            'Type',
            'Severity',
            'Status',
            'URL',
            'Method',
            'Description',
            'First Detected',
            'CWE',
            'OWASP'
        ].join(',');

        const rows = vulnerabilities.map(v => {
            return [
                `"${v.title}"`,
                v.type,
                v.severity,
                v.status,
                `"${v.requestDetails?.url || ''}"`,
                v.requestDetails?.method || '',
                `"${v.description.replace(/"/g, '""')}"`,
                new Date(v.firstDetectedAt).toISOString(),
                v.cwe || '',
                v.owasp || ''
            ].join(',');
        });

        return [headers, ...rows].join('\n');
    }

    async updateScanStats(scanId) {
        try {
            const stats = await Vulnerability.aggregate([
                { $match: { scanId: new mongoose.Types.ObjectId(scanId) } },
                {
                    $group: {
                        _id: null,
                        total: { $sum: 1 },
                        bySeverity: {
                            $push: '$severity'
                        }
                    }
                }
            ]);

            if (stats.length > 0) {
                const severityCounts = stats[0].bySeverity.reduce((acc, severity) => {
                    acc[severity] = (acc[severity] || 0) + 1;
                    return acc;
                }, {});

                await Scan.findByIdAndUpdate(scanId, {
                    'stats.vulnerabilitiesFound': stats[0].total,
                    'vulnerabilitySummary': {
                        critical: severityCounts.critical || 0,
                        high: severityCounts.high || 0,
                        medium: severityCounts.medium || 0,
                        low: severityCounts.low || 0,
                        informational: severityCounts.informational || 0
                    }
                });
            }
        } catch (error) {
            console.error('Error updating scan stats:', error);
        }
    }

    async checkDuplicateVulnerability(vulnerabilityData) {
        const { orgId, ruleId, requestId, evidence } = vulnerabilityData;

        const existing = await Vulnerability.findOne({
            orgId,
            ruleId,
            requestId,
            'evidence.request.url': evidence.request.url,
            status: 'active'
        });

        return existing;
    }

    async getVulnerabilityDetails(id, orgId) {
        try {
            // First get the vulnerability with basic populations
            const vulnerability = await Vulnerability.findOne({
                _id: id,
                orgId
            })
                .populate('scanId', 'name status createdAt completedAt')
                .lean();

            if (!vulnerability) {
                throw ApiError.notFound('Vulnerability not found');
            }

            // Fetch the complete related documents
            const [rawRequest, transformedRequest, rule] = await Promise.all([
                // Get raw request with full details
                mongoose.model('RawRequest').findById(vulnerability.requestId)
                    .select('-__v')
                    .lean(),

                // Get transformed request if it exists
                vulnerability.transformedRequestId ?
                    mongoose.model('TransformedRequest').findById(vulnerability.transformedRequestId)
                        .select('-__v')
                        .lean() :
                    null,

                // Get rule with full details
                mongoose.model('Rule').findById(vulnerability.ruleId)
                    .select('-__v')
                    .lean()
            ]);

            // Ensure all related data belongs to the same organization
            if (rawRequest && rawRequest.orgId !== orgId) {
                throw ApiError.forbidden('Access denied to related data');
            }

            // Build the comprehensive response
            const details = {
                vulnerability: {
                    ...vulnerability,
                    // Include computed fields
                    ageInDays: Math.floor((Date.now() - new Date(vulnerability.firstDetectedAt)) / (1000 * 60 * 60 * 24)),
                    isActive: vulnerability.status === 'active',
                    isResolved: ['resolved', 'false_positive'].includes(vulnerability.status)
                },
                rawRequest: rawRequest || null,
                transformedRequest: transformedRequest || null,
                rule: rule || null,

                // Add summary information
                summary: {
                    originalEndpoint: rawRequest ? `${rawRequest.method} ${rawRequest.url}` : null,
                    appliedTransformations: transformedRequest?.transformations?.length || 0,
                    ruleCategory: rule?.category || null,
                    detectionMethod: vulnerability.evidence?.matchedCriteria?.type || null
                }
            };

            return details;
        } catch (error) {
            this.handleError(error);
        }
    }

    handleError(error) {
        console.error('VulnerabilityService Error:', error);

        if (error.name === 'CastError') {
            throw ApiError.badRequest('Invalid ID format');
        }

        if (error.name === 'ValidationError') {
            const messages = Object.values(error.errors).map(e => e.message);
            throw ApiError.validationError('Validation failed', messages);
        }

        if (error instanceof ApiError) {
            throw error;
        }

        throw ApiError.internal('An error occurred while processing vulnerability operation');
    }
}