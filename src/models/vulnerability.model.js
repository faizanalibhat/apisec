import mongoose from 'mongoose';

const evidenceSchema = new mongoose.Schema({
  request: {
    method: String,
    url: String,
    headers: Object,
    body: mongoose.Schema.Types.Mixed,
    
    transformations: [{
      operation: String,
      field: String,
      value: mongoose.Schema.Types.Mixed,
      description: String
    }]
  },
  response: {
    status: Number,
    statusText: String,
    headers: Object,
    body: mongoose.Schema.Types.Mixed,
    size: Number,
    responseTime: Number
  },
  matchedCriteria: {
    type: String,
    operator: String,
    expected: mongoose.Schema.Types.Mixed,
    actual: mongoose.Schema.Types.Mixed,
    description: String
  },
  highlight: {
    type: String,
  }
});

const vulnerabilitySchema = new mongoose.Schema({
  orgId: {
    type: String,
    required: true,
  },
  scanName: { type: String },
  assessmentId: { type: String },
  scanId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Scan',
    required: true,
  },
  ruleId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Rule',
    required: true
  },
  requestId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'RawRequest',
    required: true
  },
  transformedRequestId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'TransformedRequest'
  },
  
  // Basic Information
  title: {
    type: String,
    required: true,
    trim: true
  },
  type: {
    type: String,
  },
  severity: {
    type: String,
    enum: ['critical', 'high', 'medium', 'low', 'info'],
    required: true,
    index: true
  },
  status: {
    type: String,
    enum: ['active', 'resolved'],
    default: 'active',
  },
  
  // Vulnerability Details
  description: {
    type: String,
    required: true
  },
  impact: String,
  remediation: String,
  mitigation: String,
  stepsToReproduce: String,

  tags: { type: [String], default: [] },
  
  // Technical Details
  cwe: String, // CWE ID
  owasp: String, // OWASP Category
  cvss: {
    score: Number,
    vector: String
  },
  
  // Evidence
  evidence: evidenceSchema,
  
  // Request/Rule Context
  requestDetails: {
    name: String,
    method: String,
    url: String,
    collectionName: String,
    folderName: String
  },
  ruleDetails: {
    name: String,
    category: String
  },
  
  // Verification & Notes
  verifiedAt: Date,
  verifiedBy: String,
  falsePositiveReason: String,
  notes: [{
    text: String,
    addedBy: String,
    addedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Resolution
  resolvedAt: Date,
  resolvedBy: String,
  resolutionNotes: String,
  
  // Metadata
  firstDetectedAt: {
    type: Date,
    default: Date.now
  },
  lastDetectedAt: {
    type: Date,
    default: Date.now
  },
  detectionCount: {
    type: Number,
    default: 1
  },

  universalVulnId: { type: String },
  sentToVm: { type: Boolean, default: false },
  
  // External References
  externalReferences: [{
    type: String, // 'jira', 'github', 'custom'
    id: String,
    url: String,
    title: String
  }]
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for performance
vulnerabilitySchema.index({ orgId: 1, severity: 1, status: 1 });
vulnerabilitySchema.index({ orgId: 1, type: 1, status: 1 });
vulnerabilitySchema.index({ orgId: 1, createdAt: -1 });
vulnerabilitySchema.index({ title: 'text', description: 'text', 'notes.text': 'text' });

// Virtual for age in days
vulnerabilitySchema.virtual('ageInDays').get(function() {
  return Math.floor((Date.now() - this.firstDetectedAt) / (1000 * 60 * 60 * 24));
});

// Virtual for is active
vulnerabilitySchema.virtual('isActive').get(function() {
  return this.status === 'active';
});

// Virtual for is resolved
vulnerabilitySchema.virtual('isResolved').get(function() {
  return ['resolved', 'false_positive'].includes(this.status);
});

// Method to add note
vulnerabilitySchema.methods.addNote = function(text, userId) {
  this.notes.push({
    text,
    addedBy: userId || 'system',
    addedAt: new Date()
  });
  return this.save();
};

// Method to mark as false positive
vulnerabilitySchema.methods.markAsFalsePositive = function(reason, userId) {
  this.status = 'false_positive';
  this.falsePositiveReason = reason;
  this.verifiedAt = new Date();
  this.verifiedBy = userId || 'system';
  return this.save();
};

// Method to resolve
vulnerabilitySchema.methods.resolve = function(notes, userId) {
  this.status = 'resolved';
  this.resolvedAt = new Date();
  this.resolvedBy = userId || 'system';
  this.resolutionNotes = notes;
  return this.save();
};

const Vulnerability = mongoose.model('Vulnerability', vulnerabilitySchema);

export default Vulnerability;