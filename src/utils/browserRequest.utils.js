import { ApiError } from '../utils/ApiError.js';

class BrowserRequestUtils {
  /**
   * Transform browser extension request data to raw request format
   */
  static transformBrowserData(browserData, project, orgId, projectId) {
    try {
      const { request, timestamp, tabId } = browserData;
      const { name, request: requestDetails, response } = request;

      // Extract and transform headers
      const headers = this.transformHeaders(requestDetails.header);

      // Extract and transform query params
      const params = this.extractQueryParams(requestDetails.url);

      // Build the full URL
      const url = this.buildUrl(requestDetails.url);

      // Determine body format
      const bodyFormat = this.detectBodyFormat(requestDetails.body, headers);

      return {
        orgId,
        projectIds: [projectId],
        source: 'browser-extension',
        name: name || `${requestDetails.method} ${url}`,
        method: requestDetails.method || 'GET',
        url,
        headers,
        params,
        body: requestDetails.body,
        body_format: bodyFormat,
        collectionName: project.name,
        workspaceName: project.name,
        description: `Imported from browser extension on ${new Date(timestamp).toISOString()}`,
        browserMetadata: {
          tabId,
          responseStatus: response?.status || response?.code,
          responseHeaders: response?.header || [],
          responseBody: response?.body || '',
          extensionTimestamp: new Date(timestamp).getTime()
        },
        rawHttp: null // Will be generated by the service
      };
    } catch (error) {
      throw ApiError.badRequest(`Failed to transform browser data: ${error.message}`);
    }
  }

  /**
   * Convert headers array to object
   */
  static transformHeaders(headerArray) {
    const headers = {};
    
    if (!Array.isArray(headerArray)) {
      return headers;
    }

    headerArray.forEach(header => {
      if (header.key && header.value !== undefined) {
        headers[header.key] = header.value;
      }
    });

    return headers;
  }

  /**
   * Extract query parameters from URL object
   */
  static extractQueryParams(urlObject) {
    const params = {};
    
    if (!urlObject?.query || !Array.isArray(urlObject.query)) {
      return params;
    }

    urlObject.query.forEach(param => {
      if (param.key && param.value !== undefined) {
        params[param.key] = param.value;
      }
    });

    return params;
  }

  /**
   * Build full URL from URL object components
   */
  static buildUrl(urlObject) {
    if (!urlObject) {
      return '';
    }

    // If raw URL is provided, use it
    if (urlObject.raw) {
      return urlObject.raw;
    }

    // Build URL from components
    let url = '';
    
    if (urlObject.protocol) {
      url += urlObject.protocol + '://';
    }

    if (urlObject.host && Array.isArray(urlObject.host)) {
      url += urlObject.host.join('.');
    }

    if (urlObject.port) {
      url += ':' + urlObject.port;
    }

    if (urlObject.path && Array.isArray(urlObject.path)) {
      url += '/' + urlObject.path.join('/');
    }

    if (urlObject.query && Array.isArray(urlObject.query) && urlObject.query.length > 0) {
      const queryString = urlObject.query
        .map(q => `${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`)
        .join('&');
      url += '?' + queryString;
    }

    return url;
  }

  /**
   * Detect body format based on content and headers
   */
  static detectBodyFormat(body, headers) {
    if (!body) {
      return null;
    }

    // Check Content-Type header
    const contentType = Object.keys(headers).find(key => 
      key.toLowerCase() === 'content-type'
    );

    if (contentType && headers[contentType]) {
      const contentTypeValue = headers[contentType].toLowerCase();
      
      if (contentTypeValue.includes('application/json')) {
        return 'json';
      } else if (contentTypeValue.includes('application/xml') || contentTypeValue.includes('text/xml')) {
        return 'xml';
      } else if (contentTypeValue.includes('application/x-www-form-urlencoded')) {
        return 'urlencoded';
      } else if (contentTypeValue.includes('multipart/form-data')) {
        return 'formdata';
      } else if (contentTypeValue.includes('text/')) {
        return 'text';
      }
    }

    // Try to detect format from body content
    if (typeof body === 'object') {
      return 'json';
    } else if (typeof body === 'string') {
      // Try to parse as JSON
      try {
        JSON.parse(body);
        return 'json';
      } catch {
        // Check if it looks like XML
        if (body.trim().startsWith('<') && body.trim().endsWith('>')) {
          return 'xml';
        }
        // Check if it looks like form data
        if (body.includes('=') && body.includes('&')) {
          return 'urlencoded';
        }
        return 'text';
      }
    }

    return 'raw';
  }

  /**
   * Validate browser request data structure
   */
  static validateBrowserData(data) {
    if (!data || typeof data !== 'object') {
      throw ApiError.badRequest('Invalid browser data format');
    }

    if (!data.request || typeof data.request !== 'object') {
      throw ApiError.badRequest('Missing request object in browser data');
    }

    const { request } = data.request;
    if (!request || typeof request !== 'object') {
      throw ApiError.badRequest('Missing nested request object');
    }

    if (!request.method) {
      throw ApiError.badRequest('Request method is required');
    }

    if (!request.url || !request.url.raw) {
      throw ApiError.badRequest('Request URL is required');
    }

    return true;
  }

  /**
   * Sanitize sensitive headers before storing
   */
  static sanitizeHeaders(headers) {
    const sensitiveHeaders = [
      'authorization',
      'cookie',
      'x-api-key',
      'x-auth-token',
      'x-csrf-token'
    ];

    const sanitized = { ...headers };

    Object.keys(sanitized).forEach(key => {
      if (sensitiveHeaders.includes(key.toLowerCase())) {
        // Keep first and last 4 characters, mask the rest
        const value = sanitized[key];
        if (value && value.length > 12) {
          sanitized[key] = value.substring(0, 4) + '*'.repeat(value.length - 8) + value.substring(value.length - 4);
        }
      }
    });

    return sanitized;
  }
}

export default BrowserRequestUtils;