import { VulnerabilityService } from '../services/vulnerability.service.js';
import Vulnerability from '../models/vulnerability.model.js';
import { ApiResponse } from '../utils/ApiResponse.js';
import crypto from "crypto"
import { Supression } from '../models/supression.model.js';
import { Config } from "../models/config.model.js";
import { vulnParser } from '../utils/vuln.parser.js';
import { VmAPI } from '../services/internal/vm.service.js';
import { ApiError } from '../utils/ApiError.js';



class VulnerabilityController {
    constructor() {
        this.vulnerabilityService = new VulnerabilityService();

        // Bind all methods
        this.getVulnerabilities = this.getVulnerabilities.bind(this);
        this.getVulnerability = this.getVulnerability.bind(this);
        this.updateVulnerability = this.updateVulnerability.bind(this);
        this.addNote = this.addNote.bind(this);
        this.markAsFalsePositive = this.markAsFalsePositive.bind(this);
        this.resolveVulnerability = this.resolveVulnerability.bind(this);
        this.getVulnerabilityStats = this.getVulnerabilityStats.bind(this);
        this.exportVulnerabilities = this.exportVulnerabilities.bind(this);
        this.getVulnerabilityDetails = this.getVulnerabilityDetails.bind(this);
        this.transferVulnToVM= this.transferVulnToVM.bind(this);
        this.suppressVuln= this.suppressVuln.bind(this);
        this.unSuppressVuln= this.unSuppressVuln.bind(this);
    }

    async getVulnerabilities(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const {
                // Search
                search,

                // Filters
                page = 1,
                limit = 20,
                severity,
                status,
                type,
                scanId,
                ruleId,
                supressed = false,

                // Sorting
                sortBy = 'createdAt',
                order = 'desc',

                // Grouping (for backward compatibility)
                groupBy,

                // Include details flag
                include
            } = req.query;

            const options = {
                // Search
                search,

                // Pagination
                page: parseInt(page),
                limit: parseInt(limit),

                // Filters
                severity,
                status,
                type,
                scanId,
                ruleId,
                orgId,
                supressed,

                // Sorting
                sortBy,
                order,

                // Grouping
                groupBy,

                // Include details
                includeDetails: include === 'details'
            };

            const result = await this.vulnerabilityService.getVulnerabilities(options);

            // Create the response structure with everything at root level
            const response = {
                status: 'success',
                message: 'Vulnerabilities retrieved successfully',
                data: result.data,
                pagination: {
                    page: result.page,
                    limit: result.limit,
                    total: result.total,
                    pages: result.pages
                },
                filters: result.filters,
                timestamp: new Date().toISOString(),
                summary: result.summary
            };

            // Send response directly without using sendApiResponse
            res.status(200).json(response);
        } catch (error) {
            next(error);
        }
    }

    async getVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;

            const vulnerability = await this.vulnerabilityService.getVulnerability(id, orgId);

            res.sendApiResponse(
                ApiResponse.success('Vulnerability retrieved successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async updateVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const updateData = req.body;

            const vulnerability = await this.vulnerabilityService.updateVulnerability(
                id,
                updateData,
                orgId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability updated successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async addNote(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { text } = req.body;

            const vulnerability = await this.vulnerabilityService.addNote(
                id,
                text,
                orgId,
                req.userId // Will be available after auth implementation
            );

            res.sendApiResponse(
                ApiResponse.success('Note added successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async markAsFalsePositive(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { reason } = req.body;

            const vulnerability = await this.vulnerabilityService.markAsFalsePositive(
                id,
                reason,
                orgId,
                req.userId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability marked as false positive', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async resolveVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { notes } = req.body;

            const vulnerability = await this.vulnerabilityService.resolveVulnerability(
                id,
                notes,
                orgId,
                req.userId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability resolved successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async getVulnerabilityStats(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { timeRange = '30d' } = req.query;

            const stats = await this.vulnerabilityService.getVulnerabilityStats(
                orgId,
                timeRange
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability statistics retrieved successfully', stats)
            );
        } catch (error) {
            next(error);
        }
    }

    async exportVulnerabilities(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { format = 'json', scanId, severity, status } = req.query;

            const options = {
                format,
                scanId,
                severity,
                status,
                orgId
            };

            const exportData = await this.vulnerabilityService.exportVulnerabilities(options);

            if (format === 'csv') {
                res.setHeader('Content-Type', 'text/csv');
                res.setHeader('Content-Disposition', 'attachment; filename="vulnerabilities.csv"');
                res.send(exportData);
            } else {
                res.sendApiResponse(
                    ApiResponse.success('Vulnerabilities exported successfully', exportData)
                );
            }
        } catch (error) {
            next(error);
        }
    }

    async getVulnerabilityDetails(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;

            const details = await this.vulnerabilityService.getVulnerabilityDetails(id, orgId);

            res.sendApiResponse(
                ApiResponse.success('Vulnerability details retrieved successfully', details)
            );
        } catch (error) {
            next(error);
        }
    }

    async transferVulnToVM(req, res, next) {
        const { orgId } = req.authenticatedService;
        const vulnId = req.params.id;
        
        let config = await Config.findOne({ orgId });

        if (!config) return res.status(400).json({ message: "VM config is missing" });

        config = config.toJSON();

        const { assessmentId } = config;

        let vuln = await Vulnerability.findOne({ _id: vulnId, orgId }).populate("requestId").populate("scanId").populate("transformedRequestId");

        vuln = vuln.toJSON();

        const universalVulnId = crypto.randomBytes(12).toString("hex");

        const parsedVuln = vulnParser({ ...vuln, universalVulnId, assessmentId });

        const resp = await VmAPI.importVulns({ vulns: [parsedVuln], assessmentId });

        console.log(resp);

        await Vulnerability.findOneAndUpdate({ _id: vulnId, orgId }, { $set: { universalVulnId, sentToVm: true } }, { new: true });

        return res.json({ message: "Vuln sent to VM", data: vuln });
    }

    async suppressVuln (req, res, next) {
        const { orgId } = req.authenticatedService;
        const vulnId = req.params.id;

        const vuln = await Vulnerability.findOne({ orgId, _id: vulnId });

        const supression_rule = {
            orgId,
            requestId: vuln.requestId,
            ruleId: vuln.ruleId
        }

        await Supression.create(supression_rule);

        return res.json({ message: "Vulnerability suppressed" });
    }

    async unSuppressVuln (req, res, next) {
        const { orgId } = req.authenticatedService;
        const vulnId = req.params.id;

        const vuln = await Vulnerability.findOne({ orgId, _id: vulnId });

        const supression_rule = {
            orgId,
            requestId: vuln.requestId,
            ruleId: vuln.ruleId
        }

        await Supression.deleteOne(supression_rule);

        return res.json({ message: "Vulnerability unsuppressed" });
    }
}

const vulnerabilityController = new VulnerabilityController();

export const {
    getVulnerabilities,
    getVulnerability,
    updateVulnerability,
    addNote,
    markAsFalsePositive,
    resolveVulnerability,
    getVulnerabilityStats,
    exportVulnerabilities,
    getVulnerabilityDetails,
    transferVulnToVM,
    suppressVuln,
    unSuppressVuln
} = vulnerabilityController;