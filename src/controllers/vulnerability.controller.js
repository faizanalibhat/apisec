import { VulnerabilityService } from '../services/vulnerability.service.js';
import Vulnerability from '../models/vulnerability.model.js';
import { ApiResponse } from '../utils/ApiResponse.js';
import crypto from "crypto"
import { Supression } from '../models/supression.model.js';
import { Config } from "../models/config.model.js";
import { vulnParser } from '../utils/vuln.parser.js';
import { VmAPI } from '../services/internal/vm.service.js';
import { ApiError } from '../utils/ApiError.js';
import { mqbroker } from '../services/rabbitmq.service.js';



class VulnerabilityController {

    constructor() {
        this.vulnerabilityService = new VulnerabilityService();

        // Bind all methods
        this.getVulnerabilities = this.getVulnerabilities.bind(this);
        this.getVulnerability = this.getVulnerability.bind(this);
        this.updateVulnerability = this.updateVulnerability.bind(this);
        this.addNote = this.addNote.bind(this);
        this.markAsFalsePositive = this.markAsFalsePositive.bind(this);
        this.resolveVulnerability = this.resolveVulnerability.bind(this);
        this.getVulnerabilityStats = this.getVulnerabilityStats.bind(this);
        this.exportVulnerabilities = this.exportVulnerabilities.bind(this);
        this.getVulnerabilityDetails = this.getVulnerabilityDetails.bind(this);
        this.transferVulnToVM = this.transferVulnToVM.bind(this);
        this.suppressVuln = this.suppressVuln.bind(this);
        this.unSuppressVuln = this.unSuppressVuln.bind(this);
    }

    async getVulnerabilities(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const {
                // Search
                search,

                // Filters
                page = 1,
                limit = 20,
                severity,
                status,
                type,
                scanId,
                ruleId,
                supressed = false,
                projectId,

                // Sorting
                sortBy = 'createdAt',
                order = 'desc',

                // Grouping (for backward compatibility)
                groupBy,

                // Include details flag
                include
            } = req.query;

            const filters = {
                severity,
                status,
                type,
                scanId,
                ruleId,
                supressed,
                projectId,
            };

            // Process multi-value filters
            for (const key in filters) {
                if (filters[key] && typeof filters[key] === 'string' && filters[key].includes(',')) {
                    filters[key] = filters[key].split(',').map(item => item.trim());
                }
            }

            const options = {
                // Search
                search,

                // Pagination
                page: parseInt(page),
                limit: parseInt(limit),

                // Filters
                ...filters,
                orgId,

                // Sorting
                sortBy,
                order,

                // Grouping
                groupBy,

                // Include details
                includeDetails: include === 'details'
            };

            const supression_rules = await Supression.find({ orgId });

            if (req.query.supressed == true) {
                options['requestId._id'] = { $in: supression_rules.map(rule => rule.requestId) };
                options['ruleId._id'] = { $in: supression_rules.map(rule => rule.ruleId)};
            }
            else {
                options['requestId._id'] = { $nin: supression_rules.map(rule => rule.requestId) };
                options['ruleId._id'] = { $nin: supression_rules.map(rule => rule.ruleId)};
            }

            const result = await this.vulnerabilityService.getVulnerabilities(options);

            const allVulns = result.data?.map(v => ({ ...v, isSupressed: req.query.supressed == true ? true : false }))

            // Create the response structure with everything at root level
            const response = {
                status: 'success',
                message: 'Vulnerabilities retrieved successfully',
                data: allVulns,
                pagination: {
                    page: result.page,
                    limit: result.limit,
                    total: result.total,
                    pages: result.pages
                },
                filters: result.filters,
                timestamp: new Date().toISOString(),
                summary: result.summary
            };

            // Send response directly without using sendApiResponse
            res.status(200).json(response);
        } catch (error) {
            next(error);
        }
    }

    async getVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;

            const vulnerability = await this.vulnerabilityService.getVulnerability(id, orgId);

            res.sendApiResponse(
                ApiResponse.success('Vulnerability retrieved successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async updateVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const updateData = req.body;

            const vulnerability = await this.vulnerabilityService.updateVulnerability(
                id,
                updateData,
                orgId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability updated successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async addNote(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { text } = req.body;

            const vulnerability = await this.vulnerabilityService.addNote(
                id,
                text,
                orgId,
                req.userId // Will be available after auth implementation
            );

            res.sendApiResponse(
                ApiResponse.success('Note added successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async markAsFalsePositive(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { reason } = req.body;

            const vulnerability = await this.vulnerabilityService.markAsFalsePositive(
                id,
                reason,
                orgId,
                req.userId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability marked as false positive', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async resolveVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { notes } = req.body;

            const vulnerability = await this.vulnerabilityService.resolveVulnerability(
                id,
                notes,
                orgId,
                req.userId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability resolved successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async getVulnerabilityStats(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { timeRange = '30d' } = req.query;

            const stats = await this.vulnerabilityService.getVulnerabilityStats(
                orgId,
                timeRange
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability statistics retrieved successfully', stats)
            );
        } catch (error) {
            next(error);
        }
    }

    async exportVulnerabilities(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { format = 'json', scanId, severity, status } = req.query;

            const options = {
                format,
                scanId,
                severity,
                status,
                orgId
            };

            const exportData = await this.vulnerabilityService.exportVulnerabilities(options);

            if (format === 'csv') {
                res.setHeader('Content-Type', 'text/csv');
                res.setHeader('Content-Disposition', 'attachment; filename="vulnerabilities.csv"');
                res.send(exportData);
            } else {
                res.sendApiResponse(
                    ApiResponse.success('Vulnerabilities exported successfully', exportData)
                );
            }
        } catch (error) {
            next(error);
        }
    }

    async getVulnerabilityDetails(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;

            const details = await this.vulnerabilityService.getVulnerabilityDetails(id, orgId);

            res.sendApiResponse(
                ApiResponse.success('Vulnerability details retrieved successfully', details)
            );
        } catch (error) {
            next(error);
        }
    }

    async transferVulnToVM(req, res, next) {
        const { orgId } = req.authenticatedService;
        const vulnId = req.params.id;

        let config = await Config.findOne({ orgId });

        if (!config) return res.status(400).json({ message: "VM config is missing" });

        config = config.toJSON();

        const { assessmentId } = config;

        let vuln = await Vulnerability.findOne({ _id: vulnId, orgId });

        vuln = vuln.toJSON();

        const universalVulnId = crypto.randomBytes(12).toString("hex");

        const parsedVuln = vulnParser({ ...vuln, universalVulnId, assessmentId });

        console.log("[+] SENDING VULN: ", JSON.stringify(parsedVuln));

        const resp = await VmAPI.importVulns({ vulns: [parsedVuln], assessmentId });

        if (resp?.status == "failed") {
            return res.status(400).json({ message: "Failed to import vuln to VM" });
        }

        await Vulnerability.findOneAndUpdate({ _id: vulnId, orgId }, { $set: { universalVulnId, sentToVm: true, assessmentId } }, { new: true });

        return res.json({ message: "Vuln sent to VM", data: vuln });
    }

    async suppressVuln(req, res, next) {
        const { orgId } = req.authenticatedService;
        const vulnId = req.params.id;

        try {
            // Get the vulnerability with populated details
            const vuln = await Vulnerability.findOne({ orgId, _id: vulnId });

            if (!vuln) {
                throw ApiError.notFound('Vulnerability not found');
            }

            const supression_rule = {
                orgId,
                requestId: vuln.requestId._id,
                ruleId: vuln.ruleId._id
            }

            // Check if suppression rule already exists
            const existingRule = await Supression.findOne(supression_rule);
            if (existingRule) {
                return res.status(400).json({ message: "Suppression rule already exists" });
            }

            // Create the suppression rule
            await Supression.create(supression_rule);

            // Count how many vulnerabilities will be affected by this rule
            const affectedCount = await Vulnerability.countDocuments({
                orgId,
                requestId: vuln.requestId._id,
                ruleId: vuln.ruleId._id,
                status: 'active'
            });

            // Send notification
            try {
                const notification = {
                    store: true,
                    orgId: orgId,
                    channels: ["email"],
                    notification: {
                        title: "Vulnerability Suppression Rule Created",
                        description: `Suppression rule created for "${vuln.ruleId.ruleName}" on ${vuln.requestId.method} ${vuln.requestId.url}`,
                        resourceUrl: `/vulnerabilities?suppressed=true`,
                        origin: "aim",
                        resourceMeta: {
                            product: "aim",
                            action: "vulnerability_suppression_bulk",
                            resource: "suppression_rule"
                        }
                    },
                    context: {
                        name: req.userId || "User",
                        title: "Vulnerability Suppression Rule Created",
                        description: `A new suppression rule has been created that will suppress ${affectedCount} ${affectedCount === 1 ? 'vulnerability' : 'vulnerabilities'}.

Rule Details:
• Rule: ${vuln.ruleId.ruleName}
• Endpoint: ${vuln.requestId.method} ${vuln.requestId.url}
• Request: ${vuln.requestId.name}
• Affected Vulnerabilities: ${affectedCount}

All current and future vulnerabilities matching this rule and endpoint combination will be automatically suppressed.`,
                        status: "success",
                        timestamp: Intl.DateTimeFormat('en-US', { dateStyle: 'medium', timeStyle: 'short' }).format(new Date()),
                        action_text: "View Suppressed",
                        action_url: `https://suite.snapsec.co/vulnerabilities?suppressed=true`,
                        base_url: "https://suite.snapsec.co",
                        subject: "Vulnerability Suppression Rule Created - Snapsec"
                    },
                    orgCoverage: { roles: ["Member"] },
                    authContext: req.authenticatedService || 'system'
                };

                await mqbroker.publish("notification", "notification", notification);
            } catch (notificationError) {
                console.error('Failed to send suppression notification:', notificationError);
                // Don't throw - continue with the response
            }

            return res.json({
                message: "Vulnerability suppressed",
                affectedCount: affectedCount,
                rule: {
                    endpoint: `${vuln.requestId.method} ${vuln.requestId.url}`,
                    ruleName: vuln.ruleId.ruleName
                }
            });
        } catch (error) {
            next(error);
        }
    }

    async unSuppressVuln(req, res, next) {
        const { orgId } = req.authenticatedService;
        const vulnId = req.params.id;

        const vuln = await Vulnerability.findOne({ orgId, _id: vulnId });

        const supression_rule = {
            orgId,
            requestId: vuln.requestId,
            ruleId: vuln.ruleId
        }

        await Supression.deleteOne(supression_rule);

        return res.json({ message: "Vulnerability unsuppressed" });
    }
}

const vulnerabilityController = new VulnerabilityController();

export const {
    getVulnerabilities,
    getVulnerability,
    updateVulnerability,
    addNote,
    markAsFalsePositive,
    resolveVulnerability,
    getVulnerabilityStats,
    exportVulnerabilities,
    getVulnerabilityDetails,
    transferVulnToVM,
    suppressVuln,
    unSuppressVuln
} = vulnerabilityController;