import { VulnerabilityService } from '../services/vulnerability.service.js';
import { ApiResponse } from '../utils/ApiResponse.js';
import { ApiError } from '../utils/ApiError.js';

class VulnerabilityController {
    constructor() {
        this.vulnerabilityService = new VulnerabilityService();

        // Bind all methods
        this.getVulnerabilities = this.getVulnerabilities.bind(this);
        this.getVulnerability = this.getVulnerability.bind(this);
        this.updateVulnerability = this.updateVulnerability.bind(this);
        this.addNote = this.addNote.bind(this);
        this.markAsFalsePositive = this.markAsFalsePositive.bind(this);
        this.resolveVulnerability = this.resolveVulnerability.bind(this);
        this.getVulnerabilityStats = this.getVulnerabilityStats.bind(this);
        this.exportVulnerabilities = this.exportVulnerabilities.bind(this);
        this.getVulnerabilityDetails = this.getVulnerabilityDetails.bind(this);
    }

    async getVulnerabilities(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const {
                // Search
                search,

                // Filters
                page = 1,
                limit = 20,
                severity,
                status,
                type,
                scanId,
                ruleId,

                // Sorting
                sortBy = 'createdAt',
                order = 'desc',

                // Grouping (for backward compatibility)
                groupBy,

                // Include details flag
                include
            } = req.query;

            const options = {
                // Search
                search,

                // Pagination
                page: parseInt(page),
                limit: parseInt(limit),

                // Filters
                severity,
                status,
                type,
                scanId,
                ruleId,
                orgId,

                // Sorting
                sortBy,
                order,

                // Grouping
                groupBy,

                // Include details
                includeDetails: include === 'details'
            };

            const result = await this.vulnerabilityService.getVulnerabilities(options);

            console.log("result keys: ", Object.keys(result));

            // Create the response structure with everything at root level
            const response = {
                status: 'success',
                message: 'Vulnerabilities retrieved successfully',
                data: result.data,
                pagination: {
                    page: result.page,
                    limit: result.limit,
                    total: result.total,
                    pages: result.pages
                },
                filters: result.filters,
                timestamp: new Date().toISOString(),
                summary: result.summary
            };

            // Send response directly without using sendApiResponse
            res.status(200).json(response);
        } catch (error) {
            next(error);
        }
    }

    async getVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;

            const vulnerability = await this.vulnerabilityService.getVulnerability(id, orgId);

            res.sendApiResponse(
                ApiResponse.success('Vulnerability retrieved successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async updateVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const updateData = req.body;

            const vulnerability = await this.vulnerabilityService.updateVulnerability(
                id,
                updateData,
                orgId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability updated successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async addNote(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { text } = req.body;

            const vulnerability = await this.vulnerabilityService.addNote(
                id,
                text,
                orgId,
                req.userId // Will be available after auth implementation
            );

            res.sendApiResponse(
                ApiResponse.success('Note added successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async markAsFalsePositive(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { reason } = req.body;

            const vulnerability = await this.vulnerabilityService.markAsFalsePositive(
                id,
                reason,
                orgId,
                req.userId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability marked as false positive', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async resolveVulnerability(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;
            const { notes } = req.body;

            const vulnerability = await this.vulnerabilityService.resolveVulnerability(
                id,
                notes,
                orgId,
                req.userId
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability resolved successfully', vulnerability)
            );
        } catch (error) {
            next(error);
        }
    }

    async getVulnerabilityStats(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { timeRange = '30d' } = req.query;

            const stats = await this.vulnerabilityService.getVulnerabilityStats(
                orgId,
                timeRange
            );

            res.sendApiResponse(
                ApiResponse.success('Vulnerability statistics retrieved successfully', stats)
            );
        } catch (error) {
            next(error);
        }
    }

    async exportVulnerabilities(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { format = 'json', scanId, severity, status } = req.query;

            const options = {
                format,
                scanId,
                severity,
                status,
                orgId
            };

            const exportData = await this.vulnerabilityService.exportVulnerabilities(options);

            if (format === 'csv') {
                res.setHeader('Content-Type', 'text/csv');
                res.setHeader('Content-Disposition', 'attachment; filename="vulnerabilities.csv"');
                res.send(exportData);
            } else {
                res.sendApiResponse(
                    ApiResponse.success('Vulnerabilities exported successfully', exportData)
                );
            }
        } catch (error) {
            next(error);
        }
    }

    async getVulnerabilityDetails(req, res, next) {
        try {
            const { orgId } = req.authenticatedService;
            const { id } = req.params;

            const details = await this.vulnerabilityService.getVulnerabilityDetails(id, orgId);

            res.sendApiResponse(
                ApiResponse.success('Vulnerability details retrieved successfully', details)
            );
        } catch (error) {
            next(error);
        }
    }
}

const vulnerabilityController = new VulnerabilityController();

export const {
    getVulnerabilities,
    getVulnerability,
    updateVulnerability,
    addNote,
    markAsFalsePositive,
    resolveVulnerability,
    getVulnerabilityStats,
    exportVulnerabilities,
    getVulnerabilityDetails
} = vulnerabilityController;