import { VulnerabilityService } from '../services/vulnerability.service.js';
import { ApiResponse } from '../utils/ApiResponse.js';
import { ApiError } from '../utils/ApiError.js';

class VulnerabilityController {
  constructor() {
    this.vulnerabilityService = new VulnerabilityService();
    
    // Bind all methods
    this.getVulnerabilities = this.getVulnerabilities.bind(this);
    this.getVulnerability = this.getVulnerability.bind(this);
    this.getVulnerabilitiesByScan = this.getVulnerabilitiesByScan.bind(this);
    this.updateVulnerability = this.updateVulnerability.bind(this);
    this.addNote = this.addNote.bind(this);
    this.markAsFalsePositive = this.markAsFalsePositive.bind(this);
    this.resolveVulnerability = this.resolveVulnerability.bind(this);
    this.getVulnerabilityStats = this.getVulnerabilityStats.bind(this);
    this.searchVulnerabilities = this.searchVulnerabilities.bind(this);
    this.exportVulnerabilities = this.exportVulnerabilities.bind(this);
  }

  async getVulnerabilities(req, res, next) {
    try {
      const { organizationId } = req;
      const { 
        page = 1, 
        limit = 20, 
        severity, 
        status = 'active', 
        type,
        scanId,
        ruleId,
        sortBy = 'createdAt', 
        order = 'desc' 
      } = req.query;
      
      const options = {
        page: parseInt(page),
        limit: parseInt(limit),
        severity,
        status,
        type,
        scanId,
        ruleId,
        sortBy,
        order,
        organizationId
      };
      
      const result = await this.vulnerabilityService.getVulnerabilities(options);
      
      res.sendApiResponse(
        ApiResponse.paginated(
          'Vulnerabilities retrieved successfully',
          result.data,
          {
            page: result.page,
            limit: result.limit,
            total: result.total,
            pages: result.pages
          }
        )
      );
    } catch (error) {
      next(error);
    }
  }

  async getVulnerability(req, res, next) {
    try {
      const { organizationId } = req;
      const { id } = req.params;
      
      const vulnerability = await this.vulnerabilityService.getVulnerability(id, organizationId);
      
      res.sendApiResponse(
        ApiResponse.success('Vulnerability retrieved successfully', vulnerability)
      );
    } catch (error) {
      next(error);
    }
  }

  async getVulnerabilitiesByScan(req, res, next) {
    try {
      const { organizationId } = req;
      const { scanId } = req.params;
      const { page = 1, limit = 20, severity, groupBy } = req.query;
      
      const options = {
        scanId,
        page: parseInt(page),
        limit: parseInt(limit),
        severity,
        groupBy,
        organizationId
      };
      
      const result = await this.vulnerabilityService.getVulnerabilitiesByScan(options);
      
      res.sendApiResponse(
        ApiResponse.paginated(
          'Scan vulnerabilities retrieved successfully',
          result.data,
          {
            page: result.page,
            limit: result.limit,
            total: result.total,
            pages: result.pages
          }
        )
      );
    } catch (error) {
      next(error);
    }
  }

  async updateVulnerability(req, res, next) {
    try {
      const { organizationId } = req;
      const { id } = req.params;
      const updateData = req.body;
      
      const vulnerability = await this.vulnerabilityService.updateVulnerability(
        id,
        updateData,
        organizationId
      );
      
      res.sendApiResponse(
        ApiResponse.success('Vulnerability updated successfully', vulnerability)
      );
    } catch (error) {
      next(error);
    }
  }

  async addNote(req, res, next) {
    try {
      const { organizationId } = req;
      const { id } = req.params;
      const { text } = req.body;
      
      const vulnerability = await this.vulnerabilityService.addNote(
        id,
        text,
        organizationId,
        req.userId // Will be available after auth implementation
      );
      
      res.sendApiResponse(
        ApiResponse.success('Note added successfully', vulnerability)
      );
    } catch (error) {
      next(error);
    }
  }

  async markAsFalsePositive(req, res, next) {
    try {
      const { organizationId } = req;
      const { id } = req.params;
      const { reason } = req.body;
      
      const vulnerability = await this.vulnerabilityService.markAsFalsePositive(
        id,
        reason,
        organizationId,
        req.userId
      );
      
      res.sendApiResponse(
        ApiResponse.success('Vulnerability marked as false positive', vulnerability)
      );
    } catch (error) {
      next(error);
    }
  }

  async resolveVulnerability(req, res, next) {
    try {
      const { organizationId } = req;
      const { id } = req.params;
      const { notes } = req.body;
      
      const vulnerability = await this.vulnerabilityService.resolveVulnerability(
        id,
        notes,
        organizationId,
        req.userId
      );
      
      res.sendApiResponse(
        ApiResponse.success('Vulnerability resolved successfully', vulnerability)
      );
    } catch (error) {
      next(error);
    }
  }

  async getVulnerabilityStats(req, res, next) {
    try {
      const { organizationId } = req;
      const { timeRange = '30d' } = req.query;
      
      const stats = await this.vulnerabilityService.getVulnerabilityStats(
        organizationId,
        timeRange
      );
      
      res.sendApiResponse(
        ApiResponse.success('Vulnerability statistics retrieved successfully', stats)
      );
    } catch (error) {
      next(error);
    }
  }

  async searchVulnerabilities(req, res, next) {
    try {
      const { organizationId } = req;
      const { search, page = 1, limit = 20 } = req.query;
      
      if (!search) {
        throw ApiError.badRequest('Search query is required');
      }
      
      const options = {
        search,
        page: parseInt(page),
        limit: parseInt(limit),
        organizationId
      };
      
      const result = await this.vulnerabilityService.searchVulnerabilities(options);
      
      res.sendApiResponse(
        ApiResponse.paginated(
          'Search results retrieved successfully',
          result.data,
          {
            page: result.page,
            limit: result.limit,
            total: result.total,
            pages: result.pages
          }
        )
      );
    } catch (error) {
      next(error);
    }
  }

  async exportVulnerabilities(req, res, next) {
    try {
      const { organizationId } = req;
      const { format = 'json', scanId, severity, status } = req.query;
      
      const options = {
        format,
        scanId,
        severity,
        status,
        organizationId
      };
      
      const exportData = await this.vulnerabilityService.exportVulnerabilities(options);
      
      if (format === 'csv') {
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="vulnerabilities.csv"');
        res.send(exportData);
      } else {
        res.sendApiResponse(
          ApiResponse.success('Vulnerabilities exported successfully', exportData)
        );
      }
    } catch (error) {
      next(error);
    }
  }
}

const vulnerabilityController = new VulnerabilityController();

export const {
  getVulnerabilities,
  getVulnerability,
  getVulnerabilitiesByScan,
  updateVulnerability,
  addNote,
  markAsFalsePositive,
  resolveVulnerability,
  getVulnerabilityStats,
  searchVulnerabilities,
  exportVulnerabilities
} = vulnerabilityController;